commit 18b113539bd324a69d31c6954282c9d7bccdd427
Author: Isaac Goldthwaite <igoldthwaite@kududyn.com>
Date:   Wed May 21 14:22:46 2025 -0400

    [automated] Set delta state

diff --git a/.aixcc/README.md b/.aixcc/README.md
new file mode 100644
index 00000000..17713ef4
--- /dev/null
+++ b/.aixcc/README.md
@@ -0,0 +1,16 @@
+# Libxml2 - Commentastrophe
+
+This challenge is a simple delta scan challenge.
+
+The challenge includes one synthetic vulnerability (vuln\_001) inside
+a new HTML top-comment parsing function.
+
+The delta for this challenge contains the new comment parsing functionality 
+in full.
+
+# Challenge Rounds
+
+This challenge has been included in the following set of rounds.
+
+* Exhibition Round 1
+* Exhibition Round 2
diff --git a/.aixcc/challenge.yaml b/.aixcc/challenge.yaml
new file mode 100644
index 00000000..dd5a34a7
--- /dev/null
+++ b/.aixcc/challenge.yaml
@@ -0,0 +1,39 @@
+metadata_spec_version: v1
+
+name: 'Commentastrophe'
+
+# fuzz_tooling project info that pairs to this challenge
+fuzz_tooling_project_name: 'libxml2'
+fuzz_tooling_url: "https://github.com/aixcc-finals/oss-fuzz-aixcc.git"
+fuzz_tooling_ref: "challenge-state/lx-delta-01"
+
+challenge_type: delta     # full | delta
+
+base_ref: 39ce264d546f93a0ddb7a1d7987670b8b905c165
+delta_ref: challenges/lx-delta-01
+
+
+# A list of the vulnerabilities included in this challenge
+# This should always match the dir names in .aixcc/vulns/*
+vulnerabilities:
+    - vuln_001
+
+sarif:
+    broadcast: false
+    target: null
+    correct: null
+
+# harness fuzz targets available for this challenge
+harnesses:
+    - 'api'
+    - 'html'
+    - 'lint'
+    - 'reader'
+    - 'regexp'
+    - 'schema'
+    - 'uri'
+    - 'valid'
+    - 'xinclude'
+    - 'xml'
+    - 'xpath'
+
diff --git a/.aixcc/delta.diff b/.aixcc/delta.diff
new file mode 100644
index 00000000..d1af3e02
--- /dev/null
+++ b/.aixcc/delta.diff
@@ -0,0 +1,400 @@
+diff --git a/HTMLparser.c b/HTMLparser.c
+index 59c01162..9c34e9e8 100644
+--- a/HTMLparser.c
++++ b/HTMLparser.c
+@@ -3302,6 +3302,334 @@ restart:
+     return(complete);
+ }
+ 
++/**
++ * htmlSecureComment:
++ * @ctxt:  an HTML parser context
++ * @mask:  mask of terminating characters
++ * @refs:  true if references are allowed
++ * @maxLength:  maximum output length
++ *
++ * Securely parse comment until terminator is reached.
++ *
++ * Returns the parsed string or NULL in case of errors.
++ */
++
++static xmlChar *
++htmlSecureComment(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
++              int refs, int maxLength) {
++    xmlParserInputPtr input = ctxt->input;
++    xmlChar *ret = NULL;
++    xmlChar *buffer;
++    xmlChar utf8Char[4];
++    size_t buffer_size;
++    size_t used;
++    int eof = PARSER_PROGRESSIVE(ctxt);
++    int line, col;
++    int termSkip = -1;
++
++    used = 0;
++    buffer_size = ctxt->spaceMax;
++    buffer = (xmlChar *) ctxt->spaceTab;
++    if (buffer == NULL) {
++        buffer_size = 500;
++        buffer = xmlMalloc(buffer_size + 1);
++        if (buffer == NULL) {
++            htmlErrMemory(ctxt);
++            return(NULL);
++        }
++    }
++
++    line = input->line;
++    col = input->col;
++
++    while (!PARSER_STOPPED(ctxt)) {
++        const xmlChar *chunk, *in, *repl;
++        size_t avail, chunkSize, extraSize;
++        int replSize;
++        int skip = 0;
++        int ncr = 0;
++        int ncrSize = 0;
++        int cp = 0;
++
++        chunk = input->cur;
++        avail = input->end - chunk;
++        in = chunk;
++
++        repl = BAD_CAST "";
++        replSize = 0;
++
++        while (!PARSER_STOPPED(ctxt)) {
++            size_t j;
++            int cur, size;
++
++            if ((!eof) && (avail <= 64)) {
++                size_t oldAvail = avail;
++                size_t off = in - chunk;
++
++                input->cur = in;
++
++                xmlParserGrow(ctxt);
++
++                in = input->cur;
++                chunk = in - off;
++                input->cur = chunk;
++                avail = input->end - in;
++
++                if (oldAvail == avail)
++                    eof = 1;
++            }
++
++            if (avail == 0) {
++                termSkip = 0;
++                break;
++            }
++
++            cur = *in;
++            size = 1;
++            col += 1;
++
++            if (htmlMaskMatch(mask, cur)) {
++                if (avail < 2) {
++                    termSkip = 1;
++                } else if (in[1] == '-') {
++                    if  (avail < 3) {
++                        termSkip = 2;
++                    } else if (in[2] == '>') {
++                        termSkip = 3;
++                    } else if (in[2] == '!') {
++                        if (avail < 4)
++                            termSkip = 3;
++                        else if (in[3] == '>')
++                            termSkip = 4;
++                    }
++                }
++
++                if (termSkip >= 0)
++                    break;
++            }
++
++            if (ncr) {
++                int lc = cur | 0x20;
++                int digit;
++
++                if ((cur >= '0') && (cur <= '9')) {
++                    digit = cur - '0';
++                } else if ((ncr == 16) && (lc >= 'a') && (lc <= 'f')) {
++                    digit = (lc - 'a') + 10;
++                } else {
++                    if (cur == ';') {
++                        in += 1;
++                        size += 1;
++                        ncrSize += 1;
++                    }
++                    goto next_chunk;
++                }
++
++                cp = cp * ncr + digit;
++                if (cp >= 0x110000)
++                    cp = 0x110000;
++
++                ncrSize += 1;
++
++                goto next_char;
++            }
++
++            switch (cur) {
++            case '&':
++                if (!refs)
++                    break;
++
++                j = 1;
++
++                if ((j < avail) && (in[j] == '#')) {
++                    j += 1;
++                    if (j < avail) {
++                        if ((in[j] | 0x20) == 'x') {
++                            j += 1;
++                            if ((j < avail) && (IS_HEX_DIGIT(in[j]))) {
++                                ncr = 16;
++                                size = 3;
++                                ncrSize = 3;
++                                cp = 0;
++                            }
++                        } else if (IS_ASCII_DIGIT(in[j])) {
++                            ncr = 10;
++                            size = 2;
++                            ncrSize = 2;
++                            cp = 0;
++                        }
++                    }
++                } else {
++                    repl = htmlFindEntityPrefix(in + j,
++                                                avail - j,
++                                                /* isAttr */ 1,
++                                                &skip, &replSize);
++                    if (repl != NULL) {
++                        skip += 1;
++                        goto next_chunk;
++                    }
++
++                    skip = 0;
++                }
++
++                break;
++
++            case '\0':
++                skip = 1;
++                repl = BAD_CAST "\xEF\xBF\xBD";
++                replSize = 3;
++                goto next_chunk;
++
++            case '\n':
++                line += 1;
++                col = 1;
++                break;
++
++            case '\r':
++                skip = 1;
++                if (in[1] != 0x0A) {
++                    repl = BAD_CAST "\x0A";
++                    replSize = 1;
++                }
++                goto next_chunk;
++
++            case '%':
++                char c = 0;
++
++                if ((in[1] >= '0') && (in[1] <= '9')) {
++                    c = in[1] - '0';
++                } else if ((in[1] >= 'a') && (in[1] <= 'f')) {
++                    c = (in[1] - 'a') + 10;
++                } else if ((in[1] >= 'A') && (in[1] <= 'F')) {
++                    c = (in[1] - 'F') + 10;
++                } else {
++                    break;
++                }
++
++                c <<= 4;
++
++                if ((in[2] >= '0') && (in[2] <= '9')) {
++                    c |= in[2] - '0';
++                } else if ((in[2] >= 'a') && (in[2] <= 'f')) {
++                    c |= (in[2] - 'a') + 10;
++                } else if ((in[2] >= 'A') && (in[2] <= 'F')) {
++                    c |= (in[2] - 'F') + 10;
++                } else {
++                    break;
++                }
++
++                if (IS_ASCII_DIGIT(c) || IS_ASCII_LETTER(c) ) {
++                    skip = 3;
++                    repl = BAD_CAST &c;
++                    replSize = 1;
++
++                    goto next_chunk;
++                }
++                break;
++
++            default:
++                if (cur < 0x80)
++                    break;
++
++                if ((input->flags & XML_INPUT_HAS_ENCODING) == 0) {
++                    xmlChar * guess;
++
++                    guess = htmlFindEncoding(ctxt);
++                    if (guess == NULL) {
++                        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
++                    } else {
++                        xmlSwitchEncodingName(ctxt, (const char *) guess);
++                        xmlFree(guess);
++                    }
++                    input->flags |= XML_INPUT_HAS_ENCODING;
++
++                    goto restart;
++                }
++
++                size = htmlValidateUtf8(ctxt, in, avail);
++
++                if (size <= 0) {
++                    skip = 1;
++                    repl = BAD_CAST "\xEF\xBF\xBD";
++                    replSize = 3;
++                    goto next_chunk;
++                }
++
++                break;
++            }
++
++next_char:
++            in += size;
++            avail -= size;
++        }
++
++next_chunk:
++        if (ncrSize > 0) {
++            skip = ncrSize;
++            in -= ncrSize;
++
++            repl = htmlCodePointToUtf8(cp, utf8Char, &replSize);
++        }
++
++        chunkSize = in - chunk;
++        extraSize = chunkSize + replSize;
++
++        if (extraSize > buffer_size) {
++            size_t newSize = (used + extraSize) * 2;
++            xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
++
++            if (tmp == NULL) {
++                htmlErrMemory(ctxt);
++                goto error;
++            }
++            buffer = tmp;
++            buffer_size = newSize;
++        }
++
++        if (chunkSize > 0) {
++            input->cur += chunkSize;
++            memcpy(buffer + used, chunk, chunkSize);
++            used += chunkSize;
++        }
++
++        input->cur += skip;
++        if (replSize > 0) {
++            memcpy(buffer + used, repl, replSize);
++            used += replSize;
++        }
++
++        SHRINK;
++
++        if (termSkip >= 0)
++            break;
++
++restart:
++        ;
++    }
++
++    if (termSkip > 0) {
++        input->cur += termSkip;
++        col += termSkip;
++    }
++
++    input->line = line;
++    input->col = col;
++
++    ret = xmlMalloc(used + 1);
++    if (ret == NULL) {
++        htmlErrMemory(ctxt);
++    } else {
++        memcpy(ret, buffer, used);
++        ret[used] = 0;
++    }
++
++error:
++    ctxt->spaceTab = (void *) buffer;
++    ctxt->spaceMax = buffer_size;
++
++    return(ret);
++}
++
+ /**
+  * htmlParseComment:
+  * @ctxt:  an HTML parser context
+@@ -3343,6 +3671,47 @@ htmlParseComment(htmlParserCtxtPtr ctxt, int bogus) {
+     xmlFree(buf);
+ }
+ 
++/**
++ * htmlTopParseComment:
++ * @ctxt:  an HTML parser context
++ * @bogus:  true if this is a bogus comment
++ *
++ * Parse an HTML comment at the beginning of the document
++ */
++static void
++htmlTopParseComment(htmlParserCtxtPtr ctxt, int bogus) {
++    const xmlChar *comment = BAD_CAST "";
++    xmlChar *buf = NULL;
++    int maxLength = (ctxt->options & HTML_PARSE_HUGE) ?
++                    XML_MAX_HUGE_LENGTH :
++                    XML_MAX_TEXT_LENGTH;
++
++    if (bogus) {
++        buf = htmlParseData(ctxt, MASK_GT, 0, 0, maxLength);
++        if (CUR == '>')
++            SKIP(1);
++        comment = buf;
++    } else {
++        if (CUR == '>') {
++            SKIP(1);
++        } else if ((CUR == '-') && (NXT(1) == '>')) {
++            SKIP(2);
++        } else {
++            buf = htmlSecureComment(ctxt, MASK_DASH, 0, maxLength);
++            comment = buf;
++        }
++    }
++
++    if (comment == NULL)
++        return;
++
++    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
++        (!ctxt->disableSAX))
++        ctxt->sax->comment(ctxt->userData, comment);
++
++    xmlFree(buf);
++}
++
+ /**
+  * htmlParseCharRef:
+  * @ctxt:  an HTML parser context
+@@ -4346,10 +4715,10 @@ htmlParseDocument(htmlParserCtxtPtr ctxt) {
+     while (CUR == '<') {
+         if ((NXT(1) == '!') && (NXT(2) == '-') && (NXT(3) == '-')) {
+             SKIP(4);
+-            htmlParseComment(ctxt, /* bogus */ 0);
++            htmlTopParseComment(ctxt, /* bogus */ 0);
+         } else if (NXT(1) == '?') {
+             SKIP(1);
+-            htmlParseComment(ctxt, /* bogus */ 1);
++            htmlTopParseComment(ctxt, /* bogus */ 1);
+         } else {
+             break;
+         }
diff --git a/.aixcc/test.sh b/.aixcc/test.sh
new file mode 100755
index 00000000..f60e7f3b
--- /dev/null
+++ b/.aixcc/test.sh
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+./autogen.sh
+./configure CFLAGS="-g" CXXFLAGS="-g" CC="clang" CXX="clang++"
+make all check
diff --git a/.aixcc/vulns/vuln_001/README.md b/.aixcc/vulns/vuln_001/README.md
new file mode 100644
index 00000000..9bfe7301
--- /dev/null
+++ b/.aixcc/vulns/vuln_001/README.md
@@ -0,0 +1,83 @@
+## Name
+
+Vuln 001 libxml2
+
+## Overview
+
+``libxml2`` is a robust and widely used library for parsing XML and HTML documents. It includes support for handling HTML specifically through its HTML parser, which is designed to deal with the quirks and complexities of real-world HTML, including non-well-formed documents. With ``libxml2``, you can load, parse, and manipulate HTML documents programmatically using its tree-based DOM-like API. Additionally, the library provides functions for navigating and modifying the document tree, making it a powerful tool for web scraping, data extraction, or transforming HTML content. Its HTML parser can also automatically fix common errors in malformed HTML, ensuring broader compatibility.
+
+## Vulnerability
+
+The ``libxml2`` library is capable of parsing HTML content. This vulnerability is injected into this parsing logic. At the beginning of the handler there is a check for a comment. This was handled by a generic comment parsing function but I added a special handler for the top comment. Additionally, I added a special state for handling ``%`` encoded hexadecimal values. This forces a jump to the ``next_chunk`` label. There is a memcpy that checks to copies the comment data up to that point. The check to ensure that it is within the bounds of the new buffer is modified to only check if this current chunk length is within the bounds, allowing a heap based buffer overflow.
+
+## Example crash
+
+```
+=================================================================
+==14==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x515000000775 at pc 0x562b34ae6164 bp 0x7ffef8143790 sp 0x7ffef8142f50
+WRITE of size 105 at 0x515000000775 thread T0
+SCARINESS: 45 (multi-byte-write-heap-buffer-overflow)
+    #0 0x562b34ae6163 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:63:3
+    #1 0x562b34c3941f in htmlSecureComment /src/libxml2/HTMLparser.c:3591:13
+    #2 0x562b34c3941f in htmlTopParseComment /src/libxml2/HTMLparser.c:3700:19
+    #3 0x562b34c36716 in htmlParseDocument /src/libxml2/HTMLparser.c:4718:13
+    #4 0x562b34c41272 in htmlCtxtParseDocument /src/libxml2/HTMLparser.c:6275:5
+    #5 0x562b34b27a5a in LLVMFuzzerTestOneInput /src/libxml2/fuzz/html.c:51:15
+    #6 0x562b349dc410 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
+    #7 0x562b349c7685 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6
+    #8 0x562b349cd11f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9
+    #9 0x562b349f83c2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
+    #10 0x7f510e064082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
+    #11 0x562b349bf86d in _start (/out/html+0x1ae86d)
+
+DEDUP_TOKEN: __asan_memcpy--htmlSecureComment--htmlTopParseComment
+0x515000000775 is located 0 bytes after 501-byte region [0x515000000580,0x515000000775)
+allocated by thread T0 here:
+    #0 0x562b34ae81df in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:68:3
+    #1 0x562b34b27f78 in xmlFuzzMalloc /src/libxml2/fuzz/fuzz.c:127:11
+    #2 0x562b34c38754 in htmlSecureComment /src/libxml2/HTMLparser.c:3335:18
+    #3 0x562b34c38754 in htmlTopParseComment /src/libxml2/HTMLparser.c:3700:19
+    #4 0x562b34c36716 in htmlParseDocument /src/libxml2/HTMLparser.c:4718:13
+    #5 0x562b34c41272 in htmlCtxtParseDocument /src/libxml2/HTMLparser.c:6275:5
+    #6 0x562b34b27a5a in LLVMFuzzerTestOneInput /src/libxml2/fuzz/html.c:51:15
+    #7 0x562b349dc410 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
+    #8 0x562b349c7685 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6
+    #9 0x562b349cd11f in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9
+    #10 0x562b349f83c2 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
+    #11 0x7f510e064082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 0702430aef5fa3dda43986563e9ffcc47efbd75e)
+
+DEDUP_TOKEN: __interceptor_malloc--xmlFuzzMalloc--htmlSecureComment
+SUMMARY: AddressSanitizer: heap-buffer-overflow /src/libxml2/HTMLparser.c:3591:13 in htmlSecureComment
+Shadow bytes around the buggy address:
+  0x515000000480: fd fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa
+  0x515000000500: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
+  0x515000000580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+  0x515000000600: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+  0x515000000680: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+=>0x515000000700: 00 00 00 00 00 00 00 00 00 00 00 00 00 00[05]fa
+  0x515000000780: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
+  0x515000000800: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
+  0x515000000880: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
+  0x515000000900: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
+  0x515000000980: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
+Shadow byte legend (one shadow byte represents 8 application bytes):
+  Addressable:           00
+  Partially addressable: 01 02 03 04 05 06 07
+  Heap left redzone:       fa
+  Freed heap region:       fd
+  Stack left redzone:      f1
+  Stack mid redzone:       f2
+  Stack right redzone:     f3
+  Stack after return:      f5
+  Stack use after scope:   f8
+  Global redzone:          f9
+  Global init order:       f6
+  Poisoned by user:        f7
+  Container overflow:      fc
+  Array cookie:            ac
+  Intra object redzone:    bb
+  ASan internal:           fe
+  Left alloca redzone:     ca
+  Right alloca redzone:    cb
+==14==ABORTING
+```
diff --git a/.aixcc/vulns/vuln_001/blobs/blob.bin b/.aixcc/vulns/vuln_001/blobs/blob.bin
new file mode 100644
index 00000000..40bcc6b4
--- /dev/null
+++ b/.aixcc/vulns/vuln_001/blobs/blob.bin
@@ -0,0 +1,3 @@
+<!---->
+<!--  &asd%q%41fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%41aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%41aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%41aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%41aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%41aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%41aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 22comment -->
+<html><body>hello</body></html>
diff --git a/.aixcc/vulns/vuln_001/patches/good_patch.diff b/.aixcc/vulns/vuln_001/patches/good_patch.diff
new file mode 100644
index 00000000..34218030
--- /dev/null
+++ b/.aixcc/vulns/vuln_001/patches/good_patch.diff
@@ -0,0 +1,13 @@
+diff --git a/HTMLparser.c b/HTMLparser.c
+index 91266f20..13d49574 100644
+--- a/HTMLparser.c
++++ b/HTMLparser.c
+@@ -3574,7 +3574,7 @@ next_chunk:
+         chunkSize = in - chunk;
+         extraSize = chunkSize + replSize;
+ 
+-        if (extraSize > buffer_size) {
++        if (extraSize > buffer_size - used) {
+             size_t newSize = (used + extraSize) * 2;
+             xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
+ 
diff --git a/.aixcc/vulns/vuln_001/vuln.yaml b/.aixcc/vulns/vuln_001/vuln.yaml
new file mode 100644
index 00000000..71c0f944
--- /dev/null
+++ b/.aixcc/vulns/vuln_001/vuln.yaml
@@ -0,0 +1,30 @@
+metadata_spec_version: v1
+
+name: libxml2 HTML parsing bug
+
+author: anonymous
+
+details:
+
+  cwes:
+    - CWE-122
+
+  description: >
+    Improper handling of '%' hexadecimal encoding when parsing the top comment leading to a heap-based buffer overflow.
+
+  locations:
+    - path_from_root: 'HTMLParser.c'
+      startLine: 3577
+      startColumn: 1
+      endLine: 3580
+      endColumn: 1
+
+pov:
+  blob: 'blob.bin'
+  harness: 'html'
+  architecture_build_flag: ''
+  sanitizer_build_flag: ''
+
+patch:
+  good: 'good_patch.diff'
+  bad: 'bad_patch.diff'
diff --git a/HTMLparser.c b/HTMLparser.c
index 59c01162..9c34e9e8 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -3302,6 +3302,334 @@ restart:
     return(complete);
 }
 
+/**
+ * htmlSecureComment:
+ * @ctxt:  an HTML parser context
+ * @mask:  mask of terminating characters
+ * @refs:  true if references are allowed
+ * @maxLength:  maximum output length
+ *
+ * Securely parse comment until terminator is reached.
+ *
+ * Returns the parsed string or NULL in case of errors.
+ */
+
+static xmlChar *
+htmlSecureComment(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
+              int refs, int maxLength) {
+    xmlParserInputPtr input = ctxt->input;
+    xmlChar *ret = NULL;
+    xmlChar *buffer;
+    xmlChar utf8Char[4];
+    size_t buffer_size;
+    size_t used;
+    int eof = PARSER_PROGRESSIVE(ctxt);
+    int line, col;
+    int termSkip = -1;
+
+    used = 0;
+    buffer_size = ctxt->spaceMax;
+    buffer = (xmlChar *) ctxt->spaceTab;
+    if (buffer == NULL) {
+        buffer_size = 500;
+        buffer = xmlMalloc(buffer_size + 1);
+        if (buffer == NULL) {
+            htmlErrMemory(ctxt);
+            return(NULL);
+        }
+    }
+
+    line = input->line;
+    col = input->col;
+
+    while (!PARSER_STOPPED(ctxt)) {
+        const xmlChar *chunk, *in, *repl;
+        size_t avail, chunkSize, extraSize;
+        int replSize;
+        int skip = 0;
+        int ncr = 0;
+        int ncrSize = 0;
+        int cp = 0;
+
+        chunk = input->cur;
+        avail = input->end - chunk;
+        in = chunk;
+
+        repl = BAD_CAST "";
+        replSize = 0;
+
+        while (!PARSER_STOPPED(ctxt)) {
+            size_t j;
+            int cur, size;
+
+            if ((!eof) && (avail <= 64)) {
+                size_t oldAvail = avail;
+                size_t off = in - chunk;
+
+                input->cur = in;
+
+                xmlParserGrow(ctxt);
+
+                in = input->cur;
+                chunk = in - off;
+                input->cur = chunk;
+                avail = input->end - in;
+
+                if (oldAvail == avail)
+                    eof = 1;
+            }
+
+            if (avail == 0) {
+                termSkip = 0;
+                break;
+            }
+
+            cur = *in;
+            size = 1;
+            col += 1;
+
+            if (htmlMaskMatch(mask, cur)) {
+                if (avail < 2) {
+                    termSkip = 1;
+                } else if (in[1] == '-') {
+                    if  (avail < 3) {
+                        termSkip = 2;
+                    } else if (in[2] == '>') {
+                        termSkip = 3;
+                    } else if (in[2] == '!') {
+                        if (avail < 4)
+                            termSkip = 3;
+                        else if (in[3] == '>')
+                            termSkip = 4;
+                    }
+                }
+
+                if (termSkip >= 0)
+                    break;
+            }
+
+            if (ncr) {
+                int lc = cur | 0x20;
+                int digit;
+
+                if ((cur >= '0') && (cur <= '9')) {
+                    digit = cur - '0';
+                } else if ((ncr == 16) && (lc >= 'a') && (lc <= 'f')) {
+                    digit = (lc - 'a') + 10;
+                } else {
+                    if (cur == ';') {
+                        in += 1;
+                        size += 1;
+                        ncrSize += 1;
+                    }
+                    goto next_chunk;
+                }
+
+                cp = cp * ncr + digit;
+                if (cp >= 0x110000)
+                    cp = 0x110000;
+
+                ncrSize += 1;
+
+                goto next_char;
+            }
+
+            switch (cur) {
+            case '&':
+                if (!refs)
+                    break;
+
+                j = 1;
+
+                if ((j < avail) && (in[j] == '#')) {
+                    j += 1;
+                    if (j < avail) {
+                        if ((in[j] | 0x20) == 'x') {
+                            j += 1;
+                            if ((j < avail) && (IS_HEX_DIGIT(in[j]))) {
+                                ncr = 16;
+                                size = 3;
+                                ncrSize = 3;
+                                cp = 0;
+                            }
+                        } else if (IS_ASCII_DIGIT(in[j])) {
+                            ncr = 10;
+                            size = 2;
+                            ncrSize = 2;
+                            cp = 0;
+                        }
+                    }
+                } else {
+                    repl = htmlFindEntityPrefix(in + j,
+                                                avail - j,
+                                                /* isAttr */ 1,
+                                                &skip, &replSize);
+                    if (repl != NULL) {
+                        skip += 1;
+                        goto next_chunk;
+                    }
+
+                    skip = 0;
+                }
+
+                break;
+
+            case '\0':
+                skip = 1;
+                repl = BAD_CAST "\xEF\xBF\xBD";
+                replSize = 3;
+                goto next_chunk;
+
+            case '\n':
+                line += 1;
+                col = 1;
+                break;
+
+            case '\r':
+                skip = 1;
+                if (in[1] != 0x0A) {
+                    repl = BAD_CAST "\x0A";
+                    replSize = 1;
+                }
+                goto next_chunk;
+
+            case '%':
+                char c = 0;
+
+                if ((in[1] >= '0') && (in[1] <= '9')) {
+                    c = in[1] - '0';
+                } else if ((in[1] >= 'a') && (in[1] <= 'f')) {
+                    c = (in[1] - 'a') + 10;
+                } else if ((in[1] >= 'A') && (in[1] <= 'F')) {
+                    c = (in[1] - 'F') + 10;
+                } else {
+                    break;
+                }
+
+                c <<= 4;
+
+                if ((in[2] >= '0') && (in[2] <= '9')) {
+                    c |= in[2] - '0';
+                } else if ((in[2] >= 'a') && (in[2] <= 'f')) {
+                    c |= (in[2] - 'a') + 10;
+                } else if ((in[2] >= 'A') && (in[2] <= 'F')) {
+                    c |= (in[2] - 'F') + 10;
+                } else {
+                    break;
+                }
+
+                if (IS_ASCII_DIGIT(c) || IS_ASCII_LETTER(c) ) {
+                    skip = 3;
+                    repl = BAD_CAST &c;
+                    replSize = 1;
+
+                    goto next_chunk;
+                }
+                break;
+
+            default:
+                if (cur < 0x80)
+                    break;
+
+                if ((input->flags & XML_INPUT_HAS_ENCODING) == 0) {
+                    xmlChar * guess;
+
+                    guess = htmlFindEncoding(ctxt);
+                    if (guess == NULL) {
+                        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
+                    } else {
+                        xmlSwitchEncodingName(ctxt, (const char *) guess);
+                        xmlFree(guess);
+                    }
+                    input->flags |= XML_INPUT_HAS_ENCODING;
+
+                    goto restart;
+                }
+
+                size = htmlValidateUtf8(ctxt, in, avail);
+
+                if (size <= 0) {
+                    skip = 1;
+                    repl = BAD_CAST "\xEF\xBF\xBD";
+                    replSize = 3;
+                    goto next_chunk;
+                }
+
+                break;
+            }
+
+next_char:
+            in += size;
+            avail -= size;
+        }
+
+next_chunk:
+        if (ncrSize > 0) {
+            skip = ncrSize;
+            in -= ncrSize;
+
+            repl = htmlCodePointToUtf8(cp, utf8Char, &replSize);
+        }
+
+        chunkSize = in - chunk;
+        extraSize = chunkSize + replSize;
+
+        if (extraSize > buffer_size) {
+            size_t newSize = (used + extraSize) * 2;
+            xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
+
+            if (tmp == NULL) {
+                htmlErrMemory(ctxt);
+                goto error;
+            }
+            buffer = tmp;
+            buffer_size = newSize;
+        }
+
+        if (chunkSize > 0) {
+            input->cur += chunkSize;
+            memcpy(buffer + used, chunk, chunkSize);
+            used += chunkSize;
+        }
+
+        input->cur += skip;
+        if (replSize > 0) {
+            memcpy(buffer + used, repl, replSize);
+            used += replSize;
+        }
+
+        SHRINK;
+
+        if (termSkip >= 0)
+            break;
+
+restart:
+        ;
+    }
+
+    if (termSkip > 0) {
+        input->cur += termSkip;
+        col += termSkip;
+    }
+
+    input->line = line;
+    input->col = col;
+
+    ret = xmlMalloc(used + 1);
+    if (ret == NULL) {
+        htmlErrMemory(ctxt);
+    } else {
+        memcpy(ret, buffer, used);
+        ret[used] = 0;
+    }
+
+error:
+    ctxt->spaceTab = (void *) buffer;
+    ctxt->spaceMax = buffer_size;
+
+    return(ret);
+}
+
 /**
  * htmlParseComment:
  * @ctxt:  an HTML parser context
@@ -3343,6 +3671,47 @@ htmlParseComment(htmlParserCtxtPtr ctxt, int bogus) {
     xmlFree(buf);
 }
 
+/**
+ * htmlTopParseComment:
+ * @ctxt:  an HTML parser context
+ * @bogus:  true if this is a bogus comment
+ *
+ * Parse an HTML comment at the beginning of the document
+ */
+static void
+htmlTopParseComment(htmlParserCtxtPtr ctxt, int bogus) {
+    const xmlChar *comment = BAD_CAST "";
+    xmlChar *buf = NULL;
+    int maxLength = (ctxt->options & HTML_PARSE_HUGE) ?
+                    XML_MAX_HUGE_LENGTH :
+                    XML_MAX_TEXT_LENGTH;
+
+    if (bogus) {
+        buf = htmlParseData(ctxt, MASK_GT, 0, 0, maxLength);
+        if (CUR == '>')
+            SKIP(1);
+        comment = buf;
+    } else {
+        if (CUR == '>') {
+            SKIP(1);
+        } else if ((CUR == '-') && (NXT(1) == '>')) {
+            SKIP(2);
+        } else {
+            buf = htmlSecureComment(ctxt, MASK_DASH, 0, maxLength);
+            comment = buf;
+        }
+    }
+
+    if (comment == NULL)
+        return;
+
+    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
+        (!ctxt->disableSAX))
+        ctxt->sax->comment(ctxt->userData, comment);
+
+    xmlFree(buf);
+}
+
 /**
  * htmlParseCharRef:
  * @ctxt:  an HTML parser context
@@ -4346,10 +4715,10 @@ htmlParseDocument(htmlParserCtxtPtr ctxt) {
     while (CUR == '<') {
         if ((NXT(1) == '!') && (NXT(2) == '-') && (NXT(3) == '-')) {
             SKIP(4);
-            htmlParseComment(ctxt, /* bogus */ 0);
+            htmlTopParseComment(ctxt, /* bogus */ 0);
         } else if (NXT(1) == '?') {
             SKIP(1);
-            htmlParseComment(ctxt, /* bogus */ 1);
+            htmlTopParseComment(ctxt, /* bogus */ 1);
         } else {
             break;
         }
