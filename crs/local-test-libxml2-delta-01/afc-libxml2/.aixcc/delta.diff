diff --git a/HTMLparser.c b/HTMLparser.c
index 59c01162..9c34e9e8 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -3302,6 +3302,334 @@ restart:
     return(complete);
 }
 
+/**
+ * htmlSecureComment:
+ * @ctxt:  an HTML parser context
+ * @mask:  mask of terminating characters
+ * @refs:  true if references are allowed
+ * @maxLength:  maximum output length
+ *
+ * Securely parse comment until terminator is reached.
+ *
+ * Returns the parsed string or NULL in case of errors.
+ */
+
+static xmlChar *
+htmlSecureComment(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,
+              int refs, int maxLength) {
+    xmlParserInputPtr input = ctxt->input;
+    xmlChar *ret = NULL;
+    xmlChar *buffer;
+    xmlChar utf8Char[4];
+    size_t buffer_size;
+    size_t used;
+    int eof = PARSER_PROGRESSIVE(ctxt);
+    int line, col;
+    int termSkip = -1;
+
+    used = 0;
+    buffer_size = ctxt->spaceMax;
+    buffer = (xmlChar *) ctxt->spaceTab;
+    if (buffer == NULL) {
+        buffer_size = 500;
+        buffer = xmlMalloc(buffer_size + 1);
+        if (buffer == NULL) {
+            htmlErrMemory(ctxt);
+            return(NULL);
+        }
+    }
+
+    line = input->line;
+    col = input->col;
+
+    while (!PARSER_STOPPED(ctxt)) {
+        const xmlChar *chunk, *in, *repl;
+        size_t avail, chunkSize, extraSize;
+        int replSize;
+        int skip = 0;
+        int ncr = 0;
+        int ncrSize = 0;
+        int cp = 0;
+
+        chunk = input->cur;
+        avail = input->end - chunk;
+        in = chunk;
+
+        repl = BAD_CAST "";
+        replSize = 0;
+
+        while (!PARSER_STOPPED(ctxt)) {
+            size_t j;
+            int cur, size;
+
+            if ((!eof) && (avail <= 64)) {
+                size_t oldAvail = avail;
+                size_t off = in - chunk;
+
+                input->cur = in;
+
+                xmlParserGrow(ctxt);
+
+                in = input->cur;
+                chunk = in - off;
+                input->cur = chunk;
+                avail = input->end - in;
+
+                if (oldAvail == avail)
+                    eof = 1;
+            }
+
+            if (avail == 0) {
+                termSkip = 0;
+                break;
+            }
+
+            cur = *in;
+            size = 1;
+            col += 1;
+
+            if (htmlMaskMatch(mask, cur)) {
+                if (avail < 2) {
+                    termSkip = 1;
+                } else if (in[1] == '-') {
+                    if  (avail < 3) {
+                        termSkip = 2;
+                    } else if (in[2] == '>') {
+                        termSkip = 3;
+                    } else if (in[2] == '!') {
+                        if (avail < 4)
+                            termSkip = 3;
+                        else if (in[3] == '>')
+                            termSkip = 4;
+                    }
+                }
+
+                if (termSkip >= 0)
+                    break;
+            }
+
+            if (ncr) {
+                int lc = cur | 0x20;
+                int digit;
+
+                if ((cur >= '0') && (cur <= '9')) {
+                    digit = cur - '0';
+                } else if ((ncr == 16) && (lc >= 'a') && (lc <= 'f')) {
+                    digit = (lc - 'a') + 10;
+                } else {
+                    if (cur == ';') {
+                        in += 1;
+                        size += 1;
+                        ncrSize += 1;
+                    }
+                    goto next_chunk;
+                }
+
+                cp = cp * ncr + digit;
+                if (cp >= 0x110000)
+                    cp = 0x110000;
+
+                ncrSize += 1;
+
+                goto next_char;
+            }
+
+            switch (cur) {
+            case '&':
+                if (!refs)
+                    break;
+
+                j = 1;
+
+                if ((j < avail) && (in[j] == '#')) {
+                    j += 1;
+                    if (j < avail) {
+                        if ((in[j] | 0x20) == 'x') {
+                            j += 1;
+                            if ((j < avail) && (IS_HEX_DIGIT(in[j]))) {
+                                ncr = 16;
+                                size = 3;
+                                ncrSize = 3;
+                                cp = 0;
+                            }
+                        } else if (IS_ASCII_DIGIT(in[j])) {
+                            ncr = 10;
+                            size = 2;
+                            ncrSize = 2;
+                            cp = 0;
+                        }
+                    }
+                } else {
+                    repl = htmlFindEntityPrefix(in + j,
+                                                avail - j,
+                                                /* isAttr */ 1,
+                                                &skip, &replSize);
+                    if (repl != NULL) {
+                        skip += 1;
+                        goto next_chunk;
+                    }
+
+                    skip = 0;
+                }
+
+                break;
+
+            case '\0':
+                skip = 1;
+                repl = BAD_CAST "\xEF\xBF\xBD";
+                replSize = 3;
+                goto next_chunk;
+
+            case '\n':
+                line += 1;
+                col = 1;
+                break;
+
+            case '\r':
+                skip = 1;
+                if (in[1] != 0x0A) {
+                    repl = BAD_CAST "\x0A";
+                    replSize = 1;
+                }
+                goto next_chunk;
+
+            case '%':
+                char c = 0;
+
+                if ((in[1] >= '0') && (in[1] <= '9')) {
+                    c = in[1] - '0';
+                } else if ((in[1] >= 'a') && (in[1] <= 'f')) {
+                    c = (in[1] - 'a') + 10;
+                } else if ((in[1] >= 'A') && (in[1] <= 'F')) {
+                    c = (in[1] - 'F') + 10;
+                } else {
+                    break;
+                }
+
+                c <<= 4;
+
+                if ((in[2] >= '0') && (in[2] <= '9')) {
+                    c |= in[2] - '0';
+                } else if ((in[2] >= 'a') && (in[2] <= 'f')) {
+                    c |= (in[2] - 'a') + 10;
+                } else if ((in[2] >= 'A') && (in[2] <= 'F')) {
+                    c |= (in[2] - 'F') + 10;
+                } else {
+                    break;
+                }
+
+                if (IS_ASCII_DIGIT(c) || IS_ASCII_LETTER(c) ) {
+                    skip = 3;
+                    repl = BAD_CAST &c;
+                    replSize = 1;
+
+                    goto next_chunk;
+                }
+                break;
+
+            default:
+                if (cur < 0x80)
+                    break;
+
+                if ((input->flags & XML_INPUT_HAS_ENCODING) == 0) {
+                    xmlChar * guess;
+
+                    guess = htmlFindEncoding(ctxt);
+                    if (guess == NULL) {
+                        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
+                    } else {
+                        xmlSwitchEncodingName(ctxt, (const char *) guess);
+                        xmlFree(guess);
+                    }
+                    input->flags |= XML_INPUT_HAS_ENCODING;
+
+                    goto restart;
+                }
+
+                size = htmlValidateUtf8(ctxt, in, avail);
+
+                if (size <= 0) {
+                    skip = 1;
+                    repl = BAD_CAST "\xEF\xBF\xBD";
+                    replSize = 3;
+                    goto next_chunk;
+                }
+
+                break;
+            }
+
+next_char:
+            in += size;
+            avail -= size;
+        }
+
+next_chunk:
+        if (ncrSize > 0) {
+            skip = ncrSize;
+            in -= ncrSize;
+
+            repl = htmlCodePointToUtf8(cp, utf8Char, &replSize);
+        }
+
+        chunkSize = in - chunk;
+        extraSize = chunkSize + replSize;
+
+        if (extraSize > buffer_size) {
+            size_t newSize = (used + extraSize) * 2;
+            xmlChar *tmp = (xmlChar *) xmlRealloc(buffer, newSize + 1);
+
+            if (tmp == NULL) {
+                htmlErrMemory(ctxt);
+                goto error;
+            }
+            buffer = tmp;
+            buffer_size = newSize;
+        }
+
+        if (chunkSize > 0) {
+            input->cur += chunkSize;
+            memcpy(buffer + used, chunk, chunkSize);
+            used += chunkSize;
+        }
+
+        input->cur += skip;
+        if (replSize > 0) {
+            memcpy(buffer + used, repl, replSize);
+            used += replSize;
+        }
+
+        SHRINK;
+
+        if (termSkip >= 0)
+            break;
+
+restart:
+        ;
+    }
+
+    if (termSkip > 0) {
+        input->cur += termSkip;
+        col += termSkip;
+    }
+
+    input->line = line;
+    input->col = col;
+
+    ret = xmlMalloc(used + 1);
+    if (ret == NULL) {
+        htmlErrMemory(ctxt);
+    } else {
+        memcpy(ret, buffer, used);
+        ret[used] = 0;
+    }
+
+error:
+    ctxt->spaceTab = (void *) buffer;
+    ctxt->spaceMax = buffer_size;
+
+    return(ret);
+}
+
 /**
  * htmlParseComment:
  * @ctxt:  an HTML parser context
@@ -3343,6 +3671,47 @@ htmlParseComment(htmlParserCtxtPtr ctxt, int bogus) {
     xmlFree(buf);
 }
 
+/**
+ * htmlTopParseComment:
+ * @ctxt:  an HTML parser context
+ * @bogus:  true if this is a bogus comment
+ *
+ * Parse an HTML comment at the beginning of the document
+ */
+static void
+htmlTopParseComment(htmlParserCtxtPtr ctxt, int bogus) {
+    const xmlChar *comment = BAD_CAST "";
+    xmlChar *buf = NULL;
+    int maxLength = (ctxt->options & HTML_PARSE_HUGE) ?
+                    XML_MAX_HUGE_LENGTH :
+                    XML_MAX_TEXT_LENGTH;
+
+    if (bogus) {
+        buf = htmlParseData(ctxt, MASK_GT, 0, 0, maxLength);
+        if (CUR == '>')
+            SKIP(1);
+        comment = buf;
+    } else {
+        if (CUR == '>') {
+            SKIP(1);
+        } else if ((CUR == '-') && (NXT(1) == '>')) {
+            SKIP(2);
+        } else {
+            buf = htmlSecureComment(ctxt, MASK_DASH, 0, maxLength);
+            comment = buf;
+        }
+    }
+
+    if (comment == NULL)
+        return;
+
+    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
+        (!ctxt->disableSAX))
+        ctxt->sax->comment(ctxt->userData, comment);
+
+    xmlFree(buf);
+}
+
 /**
  * htmlParseCharRef:
  * @ctxt:  an HTML parser context
@@ -4346,10 +4715,10 @@ htmlParseDocument(htmlParserCtxtPtr ctxt) {
     while (CUR == '<') {
         if ((NXT(1) == '!') && (NXT(2) == '-') && (NXT(3) == '-')) {
             SKIP(4);
-            htmlParseComment(ctxt, /* bogus */ 0);
+            htmlTopParseComment(ctxt, /* bogus */ 0);
         } else if (NXT(1) == '?') {
             SKIP(1);
-            htmlParseComment(ctxt, /* bogus */ 1);
+            htmlTopParseComment(ctxt, /* bogus */ 1);
         } else {
             break;
         }
